"""
Claude Agent SDK wrapper for streaming interactions.
Supports both streaming (for user-facing) and blocking (for sub-agents) modes.
"""
import asyncio
import json
import logging
import sys
import os
from enum import Enum
from typing import Any, AsyncGenerator, Optional
from dataclasses import dataclass, field

from claude_agent_sdk import (
    query,
    ClaudeAgentOptions,
    ClaudeSDKClient,
    AssistantMessage,
    UserMessage,
    ResultMessage,
    SystemMessage,
    TextBlock,
    ThinkingBlock,
    ToolUseBlock,
    ToolResultBlock,
    tool,
    create_sdk_mcp_server,
)
from claude_agent_sdk.types import StreamEvent as SDKStreamEvent

from models.settings import AppSettings, MCPServerConfig
from core.search_tools import get_serper_tool, get_tavily_tool, get_brave_tool
from core.user_input_handler import user_input_handler

import httpx
from typing import Callable, Awaitable
from fastapi import WebSocket

# Set up logging
logger = logging.getLogger(__name__)


class StreamEventType(str, Enum):
    """Event types for agent streaming."""
    # Lifecycle events
    START = "start"
    DONE = "done"
    ERROR = "error"
    
    # Legacy/aggregated events (backward compatible)
    THINKING = "thinking"
    TEXT = "text"
    TOOL_USE = "tool_use"
    TOOL_RESULT = "tool_result"
    
    # Incremental text events
    TEXT_START = "text_start"
    TEXT_DELTA = "text_delta"
    TEXT_END = "text_end"
    
    # Incremental tool events
    TOOL_INPUT_START = "tool_input_start"
    TOOL_INPUT_DELTA = "tool_input_delta"
    TOOL_INPUT_END = "tool_input_end"
    
    # Incremental thinking events
    THINKING_START = "thinking_start"
    THINKING_DELTA = "thinking_delta"
    THINKING_END = "thinking_end"


@dataclass
class Usage:
    """Token usage statistics."""
    input_tokens: int = 0
    output_tokens: int = 0
    total_tokens: int = 0
    
    def to_dict(self) -> dict:
        return {
            "input_tokens": self.input_tokens,
            "output_tokens": self.output_tokens,
            "total_tokens": self.total_tokens,
        }


@dataclass
class StreamEvent:
    """Event emitted during agent streaming."""
    type: str  # StreamEventType value
    content: Any = None
    metadata: dict = field(default_factory=dict)
    id: Optional[str] = None
    usage: Optional[Usage] = None
    
    def to_dict(self) -> dict:
        result = {
            "type": self.type,
            "content": self.content,
            "metadata": self.metadata,
        }
        if self.id:
            result["id"] = self.id
        if self.usage:
            result["usage"] = self.usage.to_dict()
        return result
    
    def to_json(self) -> str:
        return json.dumps(self.to_dict())


@dataclass
class AgentResponse:
    """Aggregated response for blocking invoke() calls."""
    text: str
    tool_calls: list[dict]
    events: list[StreamEvent]
    usage: Usage
    
    def to_dict(self) -> dict:
        return {
            "text": self.text,
            "tool_calls": self.tool_calls,
            "events": [e.to_dict() for e in self.events],
            "usage": self.usage.to_dict(),
        }


def build_mcp_servers(configs: list[MCPServerConfig]) -> dict:
    """Build MCP server configuration dict from settings."""
    servers = {}
    for cfg in configs:
        if not cfg.enabled:
            continue
        if cfg.type == "stdio":
            servers[cfg.name] = {
                "type": "stdio",
                "command": cfg.command,
                "args": cfg.args,
                "env": cfg.env,
            }
        elif cfg.type == "sse":
            # Legacy SSE transport (GET /sse + POST /message)
            servers[cfg.name] = {
                "type": "sse",
                "url": cfg.url,
            }
        elif cfg.type == "http":
            # Streamable HTTP transport (unified POST /mcp endpoint)
            servers[cfg.name] = {
                "type": "http",
                "url": cfg.url,
            }
        # SDK type handled separately
    return servers


def build_agent_options(
    settings: AppSettings, 
    streaming: bool = True,
    can_use_tool: Optional[Callable] = None,
) -> ClaudeAgentOptions:
    """Build ClaudeAgentOptions from app settings."""
    # Use 'default' permission mode if can_use_tool is provided, otherwise bypass
    permission_mode = 'default' if can_use_tool else 'bypassPermissions'
    
    options = ClaudeAgentOptions(
        allowed_tools=settings.allowed_tools.copy(),  # Copy to avoid mutating original settings
        disallowed_tools=['WebSearch', 'WebFetch'],  # Disable built-in search to use MCP search instead
        max_turns=settings.max_turns,
        include_partial_messages=streaming,  # Enable incremental events for streaming
        permission_mode=permission_mode,
        can_use_tool=can_use_tool,
        system_prompt="You are a helpful AI assistant. Always format your responses in clean, structured Markdown. Use bold headings, bullet points, and tables where appropriate to present information clearly. When utilizing tools, briefly explain your actions to the user."
    )
    
    # Set model for ANY provider if specified
    if settings.model.model_name:
        options.model = settings.model.model_name
    
    # Get active endpoint config (from multi-endpoint or legacy fields)
    active_endpoint = settings.model.get_active_endpoint()
    if active_endpoint:
        provider = active_endpoint.provider
        api_key = active_endpoint.api_key
        endpoint_url = active_endpoint.endpoint
    else:
        # Fallback to legacy single-endpoint fields
        provider = settings.model.provider
        api_key = settings.model.api_key
        endpoint_url = settings.model.endpoint
    
    # Configure Environment for Custom Endpoints
    env_vars = {}
    
    # Set Base URL if provided
    if endpoint_url:
        # Strip /v1 suffix if present as SDK likely appends it or /v1/messages
        endpoint = endpoint_url.rstrip("/")
        if endpoint.endswith("/v1"):
            endpoint = endpoint[:-3]
        env_vars["ANTHROPIC_BASE_URL"] = endpoint
    elif provider == "openrouter":
        # OpenRouter's Anthropic-compatible endpoint
        env_vars["ANTHROPIC_BASE_URL"] = "https://openrouter.ai/api"
        # OpenRouter requires: AUTH_TOKEN for key, empty API_KEY
        if api_key:
            env_vars["ANTHROPIC_AUTH_TOKEN"] = api_key
        env_vars["ANTHROPIC_API_KEY"] = ""  # Must be empty for OpenRouter
    elif provider == "local":
        # Default local endpoint if not explicitly set
        env_vars["ANTHROPIC_BASE_URL"] = "http://localhost:1234/v1"
        
    # Handle API Key (for non-OpenRouter providers)
    if provider != "openrouter":
        if api_key:
            env_vars["ANTHROPIC_API_KEY"] = api_key
        elif provider == "local":
            # Local providers often need a dummy key if none provided
            env_vars["ANTHROPIC_API_KEY"] = "sk-dummy-key"
    
    # Token limits - only set if > 0
    if settings.model.max_tokens > 0:
        env_vars["CLAUDE_CODE_MAX_OUTPUT_TOKENS"] = str(settings.model.max_tokens)
    if settings.model.max_thinking_tokens > 0:
        env_vars["MAX_THINKING_TOKENS"] = str(settings.model.max_thinking_tokens)
        
    if env_vars:
        options.env = env_vars
    
    # Set MCP servers
    mcp_servers = build_mcp_servers(settings.mcp_servers)
    
    # Configure Search Tool via Stdio MCP Server
    if settings.search.enabled and settings.search.provider in ["serper", "tavily", "brave"] and settings.search.api_key:
        server_script = os.path.join(os.path.dirname(os.path.abspath(__file__)), "run_search_server.py")
        
        # Add Stdio MCP Server configuration
        mcp_servers["search-tools"] = {
            "command": sys.executable,
            "args": [server_script],
            "env": {
                **os.environ,
                "PYTHONUNBUFFERED": "1" # Ensure output is flushed
            }
        }
        
        # Add tool to allowed_tools to prevent permission errors
        # SDK namespaces MCP tools as mcp__{server_name}__{tool_name}
        tool_simple_name = f"{settings.search.provider}_search"
        full_tool_name = f"mcp__search-tools__{tool_simple_name}"
        
        if options.allowed_tools:
            # Only add if not already present
            if full_tool_name not in options.allowed_tools:
                options.allowed_tools.append(full_tool_name)
        else:
            options.allowed_tools = [full_tool_name]

    if mcp_servers:
        options.mcp_servers = mcp_servers
    
    # Set default working directory if configured
    if settings.default_workdir:
        options.cwd = settings.default_workdir
        
    return options


def _process_stream_event(sdk_event: SDKStreamEvent, block_state: dict) -> list[StreamEvent]:
    """Process SDK StreamEvent and return our StreamEvents."""
    events = []
    raw_event = sdk_event.event
    event_type = raw_event.get("type")
    
    if event_type == "message_start":
        events.append(StreamEvent(type=StreamEventType.START.value))
        
    elif event_type == "content_block_start":
        index = raw_event.get("index", 0)
        content_block = raw_event.get("content_block", {})
        block_type = content_block.get("type")
        
        if block_type == "text":
            block_id = f"text_{sdk_event.uuid}_{index}"
            block_state[index] = {"type": "text", "id": block_id, "content": ""}
            events.append(StreamEvent(
                type=StreamEventType.TEXT_START.value,
                id=block_id,
            ))
        elif block_type == "tool_use":
            tool_id = content_block.get("id", f"tool_{index}")
            tool_name = content_block.get("name", "unknown")
            block_state[index] = {
                "type": "tool",
                "id": tool_id,
                "name": tool_name,
                "input_buffer": ""
            }
            events.append(StreamEvent(
                type=StreamEventType.TOOL_INPUT_START.value,
                id=tool_id,
                content={"name": tool_name},
            ))
        elif block_type == "thinking":
            block_id = f"thinking_{index}"
            block_state[index] = {"type": "thinking", "id": block_id, "content": ""}
            logger.info(f"ðŸ§  THINKING_START: Thinking block started (index={index}, id={block_id})")
            events.append(StreamEvent(
                type=StreamEventType.THINKING_START.value,
                id=block_id,
            ))
            
    elif event_type == "content_block_delta":
        index = raw_event.get("index", 0)
        delta = raw_event.get("delta", {})
        delta_type = delta.get("type")
        
        block = block_state.get(index)
        if not block:
            return events
            
        if delta_type == "text_delta" and block["type"] == "text":
            text = delta.get("text", "")
            block["content"] += text
            events.append(StreamEvent(
                type=StreamEventType.TEXT_DELTA.value,
                id=block["id"],
                content=text,
            ))
        elif delta_type == "thinking_delta" and block["type"] == "thinking":
            text = delta.get("thinking", "")
            block["content"] += text
            logger.debug(f"ðŸ§  THINKING_DELTA: {len(text)} chars received")
            # Emit thinking delta event for real-time updates
            events.append(StreamEvent(
                type=StreamEventType.THINKING_DELTA.value,
                id=block["id"],
                content=text,
            ))
        elif delta_type == "input_json_delta" and block["type"] == "tool":
            partial = delta.get("partial_json", "")
            block["input_buffer"] += partial
            events.append(StreamEvent(
                type=StreamEventType.TOOL_INPUT_DELTA.value,
                id=block["id"],
                content=partial,
            ))
            
    elif event_type == "content_block_stop":
        index = raw_event.get("index", 0)
        block = block_state.pop(index, None)
        if block:
            if block["type"] == "text":
                events.append(StreamEvent(
                    type=StreamEventType.TEXT_END.value,
                    id=block["id"],
                ))
                # Also emit legacy TEXT event for backward compatibility
                if block["content"]:
                    events.append(StreamEvent(
                        type=StreamEventType.TEXT.value,
                        content=block["content"],
                    ))
            elif block["type"] == "tool":
                events.append(StreamEvent(
                    type=StreamEventType.TOOL_INPUT_END.value,
                    id=block["id"],
                ))
            elif block["type"] == "thinking":
                logger.info(f"ðŸ§  THINKING_END: Thinking block ended (id={block['id']}, content_length={len(block['content'])})")
                events.append(StreamEvent(
                    type=StreamEventType.THINKING_END.value,
                    id=block["id"],
                ))
                # Also emit legacy THINKING event for backward compatibility
                if block["content"]:
                    events.append(StreamEvent(
                        type=StreamEventType.THINKING.value,
                        content=block["content"],
                    ))
                    
    elif event_type == "message_delta":
        # Extract usage info
        usage_data = raw_event.get("usage", {})
        if usage_data:
            usage = Usage(
                input_tokens=usage_data.get("input_tokens", 0),
                output_tokens=usage_data.get("output_tokens", 0),
                total_tokens=usage_data.get("input_tokens", 0) + usage_data.get("output_tokens", 0),
            )
            # Store in block_state for final event
            block_state["_usage"] = usage
            
    return events


async def stream_agent_response(
    prompt: str,
    settings: AppSettings,
    cwd: Optional[str] = None,
    streaming: bool = True,
    resume_session_id: Optional[str] = None,
    websocket: Optional[WebSocket] = None,
) -> AsyncGenerator[StreamEvent, None]:
    """
    Stream agent responses as events.
    
    Args:
        prompt: User prompt
        settings: Application settings
        cwd: Working directory
        streaming: If True, emit incremental events (text_delta, etc.)
                   If False, only emit aggregated events (text, tool_use, etc.)
        resume_session_id: SDK session ID to resume
        websocket: WebSocket connection for user input requests (AskUserQuestion)
    
    Yields StreamEvent objects with types:
    - "start": Stream started
    - "text_start/delta/end": Incremental text (when streaming=True)
    - "text": Complete text block (always)
    - "thinking": Thinking content
    - "tool_input_start/delta/end": Incremental tool input (when streaming=True)
    - "tool_use": Tool invocation
    - "tool_result": Tool execution result
    - "ask_user": Claude is asking the user a question
    - "error": Error occurred
    - "done": Streaming complete with usage stats
    """
    import uuid
    
    logger.info(f"Starting stream_agent_response for prompt: {prompt[:100]}...")
    
    # TODO: AskUserQuestion support requires ClaudeSDKClient instead of query()
    # The can_use_tool callback with streaming mode requires using ClaudeSDKClient
    # for bidirectional communication. For now, we use bypassPermissions mode.
    # See: https://docs.anthropic.com/en/docs/claude-code/sdk/user-input
    can_use_tool_callback = None
    
    # Future implementation would use ClaudeSDKClient:
    # if websocket:
    #     async def can_use_tool(tool_name: str, input_data: dict, context):
    #         if tool_name == "AskUserQuestion":
    #             # Route to frontend via websocket
    #             ...
    #         return PermissionResultAllow()
    #     can_use_tool_callback = can_use_tool
    
    try:
        options = build_agent_options(settings, streaming=streaming, can_use_tool=can_use_tool_callback)
        if cwd:
            options.cwd = cwd
        
        # Support session resumption
        if resume_session_id:
            options.resume = resume_session_id
            logger.info(f"Resuming SDK session: {resume_session_id}")
        
        logger.info(f"Agent options: model={options.model}, max_turns={options.max_turns}, resume={getattr(options, 'resume', None)}")
        
        turn_count = 0
        message_count = 0
        block_state = {}  # Track active content blocks for streaming
        total_usage = Usage()
        
        logger.info("Starting SDK query loop...")
        
        async for message in query(prompt=prompt, options=options):
            message_count += 1
            message_type = type(message).__name__
            logger.debug(f"Received message #{message_count}: type={message_type}")
            
            # Handle incremental stream events
            if isinstance(message, SDKStreamEvent):
                stream_events = _process_stream_event(message, block_state)
                for event in stream_events:
                    yield event
                # Update usage if available
                if "_usage" in block_state:
                    total_usage = block_state["_usage"]
                continue

            if isinstance(message, AssistantMessage):
                turn_count += 1
                logger.info(f"AssistantMessage turn {turn_count}: {len(message.content)} content blocks")
                for block in message.content:
                    if isinstance(block, TextBlock):
                        # Check if it's thinking content
                        if getattr(block, "type", None) == "thinking":
                            yield StreamEvent(
                                type=StreamEventType.THINKING.value,
                                content=block.text,
                                metadata={"turn": turn_count}
                            )
                        else:
                            # Skip emitting TEXT here if streaming is enabled
                            # because text_delta events already provide the content incrementally.
                            # The TEXT event from AssistantMessage would be duplicate.
                            text_preview = block.text[:100] if block.text else ""
                            logger.info(f"AssistantMessage text (turn {turn_count}): {text_preview}...")
                            # Only emit if not streaming (streaming=False case)
                            if not streaming:
                                yield StreamEvent(
                                    type=StreamEventType.TEXT.value,
                                    content=block.text,
                                    metadata={"turn": turn_count}
                                )
                    elif isinstance(block, ThinkingBlock):
                        yield StreamEvent(
                            type=StreamEventType.THINKING.value,
                            content=block.thinking,
                            metadata={"turn": turn_count}
                        )
                    elif isinstance(block, ToolUseBlock):
                        # Log tool use with input preview for debugging
                        input_preview = str(block.input)[:200] if block.input else "None"
                        logger.info(f"Tool use: name={block.name}, id={block.id}, input={input_preview}")
                        
                        # Special logging for TodoWrite to debug todo list issues
                        if block.name == "TodoWrite":
                            logger.info(f"TodoWrite full input: {block.input}")
                        
                        yield StreamEvent(
                            type=StreamEventType.TOOL_USE.value,
                            content={
                                "id": block.id,
                                "name": block.name,
                                "input": block.input,
                            },
                            metadata={"turn": turn_count}
                        )
            
            elif isinstance(message, UserMessage):
                # UserMessage contains tool results after tool execution
                for block in message.content:
                    if isinstance(block, ToolResultBlock):
                        is_error = getattr(block, "is_error", False)
                        result_preview = str(block.content)[:200] if block.content else "None"
                        logger.info(f"Tool result: tool_use_id={block.tool_use_id}, is_error={is_error}, result={result_preview}...")
                        yield StreamEvent(
                            type=StreamEventType.TOOL_RESULT.value,
                            content={
                                "tool_use_id": block.tool_use_id,
                                "result": block.content,
                                "is_error": is_error,
                            },
                            metadata={"turn": turn_count}
                        )
            
            elif isinstance(message, SystemMessage):
                # SystemMessage can contain todos, init info, etc.
                logger.info(f"SystemMessage received: subtype={message.subtype}, data_keys={list(message.data.keys()) if message.data else []}")
                
                # Check for todos in the system message
                if message.data and 'todos' in message.data:
                    todos = message.data['todos']
                    logger.info(f"SystemMessage contains todos: {todos}")
                    yield StreamEvent(
                        type="todos",
                        content={"todos": todos},
                        metadata={"subtype": message.subtype}
                    )
                # Also log init messages for debugging
                elif message.subtype == 'init':
                    sdk_session_id = message.data.get('session_id')
                    logger.info(f"Session init: session_id={sdk_session_id}, tools={message.data.get('tools', [])[:5]}...")
                    # Emit sdk_session_id for session persistence
                    if sdk_session_id:
                        yield StreamEvent(
                            type="system",
                            content={"sdk_session_id": sdk_session_id},
                            metadata={"subtype": "init"}
                        )
            
            elif isinstance(message, ResultMessage):
                # ResultMessage is the FINAL session result, not individual tool result
                # Only extract usage info here
                logger.info(f"ResultMessage received: subtype={getattr(message, 'subtype', 'unknown')}, is_error={getattr(message, 'is_error', False)}")
                if message.usage:
                    total_usage = Usage(
                        input_tokens=message.usage.get("input_tokens", 0),
                        output_tokens=message.usage.get("output_tokens", 0),
                        total_tokens=message.usage.get("input_tokens", 0) + message.usage.get("output_tokens", 0),
                    )
        
        logger.info(f"SDK query loop finished. Total messages: {message_count}, Total turns: {turn_count}")
        
        yield StreamEvent(
            type=StreamEventType.DONE.value,
            content={"total_turns": turn_count},
            usage=total_usage,
        )
    
    except Exception as e:
        import traceback
        logger.error(f"Error in stream_agent_response: {e}", exc_info=True)
        traceback.print_exc()
        yield StreamEvent(
            type=StreamEventType.ERROR.value,
            content=str(e),
            metadata={"error_type": type(e).__name__}
        )


async def invoke_agent(
    prompt: str,
    settings: AppSettings,
    cwd: Optional[str] = None,
) -> AgentResponse:
    """
    Blocking agent call for sub-agents and background tasks.
    
    Returns aggregated AgentResponse instead of streaming events.
    Internally uses streaming but collects all events before returning.
    """
    events = []
    text_parts = []
    tool_calls = []
    final_usage = Usage()
    
    async for event in stream_agent_response(
        prompt=prompt,
        settings=settings,
        cwd=cwd,
        streaming=False,  # Disable incremental events for simpler processing
    ):
        events.append(event)
        
        if event.type == StreamEventType.TEXT.value:
            text_parts.append(event.content)
        elif event.type == StreamEventType.TOOL_USE.value:
            tool_calls.append(event.content)
        elif event.type == StreamEventType.DONE.value:
            if event.usage:
                final_usage = event.usage
    
    return AgentResponse(
        text="".join(text_parts),
        tool_calls=tool_calls,
        events=events,
        usage=final_usage,
    )


class AgentSession:
    """
    Manages an interactive agent session using ClaudeSDKClient.
    Supports multi-turn conversations with session resumption.
    """
    
    def __init__(
        self, 
        settings: AppSettings, 
        cwd: Optional[str] = None,
        resume_session_id: Optional[str] = None
    ):
        self.settings = settings
        self.cwd = cwd
        self.resume_session_id = resume_session_id
        self.client: Optional[ClaudeSDKClient] = None
        self.history: list[dict] = []
        self.sdk_session_id: Optional[str] = None  # Captured from SDK init message
    
    async def start(self) -> None:
        """Start the agent session, optionally resuming from a previous session."""
        options = build_agent_options(self.settings)
        if self.cwd:
            options.cwd = self.cwd
        
        # If resuming, set the resume option
        if self.resume_session_id:
            options.resume = self.resume_session_id
            logger.info(f"[AgentSession] Resuming from SDK session: {self.resume_session_id}")
        
        self.client = ClaudeSDKClient(options=options)
        await self.client.__aenter__()
    
    async def stop(self) -> None:
        """Stop the agent session."""
        if self.client:
            await self.client.__aexit__(None, None, None)
            self.client = None
    
    async def send_message(self, message: str) -> AsyncGenerator[StreamEvent, None]:
        """Send a message and stream the response."""
        if not self.client:
            yield StreamEvent(type=StreamEventType.ERROR.value, content="Session not started")
            return
        
        try:
            await self.client.query(message)
            self.history.append({"role": "user", "content": message})
            
            turn_count = 0
            # Use receive_messages() to get all message types
            async for msg in self.client.receive_messages():
                # Capture SDK session_id from SystemMessage (init)
                if isinstance(msg, SystemMessage):
                    if hasattr(msg, 'subtype') and msg.subtype == 'init':
                        if hasattr(msg, 'data') and isinstance(msg.data, dict):
                            new_session_id = msg.data.get('session_id')
                            if new_session_id:
                                self.sdk_session_id = new_session_id
                                logger.info(f"[AgentSession] Captured SDK session_id: {new_session_id}")
                                # Emit a system event with the session_id
                                yield StreamEvent(
                                    type="system",
                                    content={"sdk_session_id": new_session_id},
                                    metadata={"subtype": "init"}
                                )
                
                elif isinstance(msg, AssistantMessage):
                    turn_count += 1
                    for block in msg.content:
                        if isinstance(block, TextBlock):
                            yield StreamEvent(
                                type=StreamEventType.TEXT.value,
                                content=block.text,
                                metadata={"turn": turn_count}
                            )
                        elif isinstance(block, ToolUseBlock):
                            yield StreamEvent(
                                type=StreamEventType.TOOL_USE.value,
                                content={
                                    "id": block.id,
                                    "name": block.name,
                                    "input": block.input,
                                },
                                metadata={"turn": turn_count}
                            )
                        elif isinstance(block, ThinkingBlock):
                            yield StreamEvent(
                                type=StreamEventType.THINKING.value,
                                content=block.thinking,
                                metadata={"turn": turn_count}
                            )
                
                elif isinstance(msg, UserMessage):
                    # UserMessage contains tool results
                    for block in msg.content:
                        if isinstance(block, ToolResultBlock):
                            yield StreamEvent(
                                type=StreamEventType.TOOL_RESULT.value,
                                content={
                                    "tool_use_id": block.tool_use_id,
                                    "content": block.content,
                                    "is_error": getattr(block, 'is_error', False),
                                },
                                metadata={"turn": turn_count}
                            )
                
                elif isinstance(msg, ResultMessage):
                    # End of conversation turn
                    break
            
            yield StreamEvent(type=StreamEventType.DONE.value, content={"total_turns": turn_count})
        
        except Exception as e:
            yield StreamEvent(
                type=StreamEventType.ERROR.value,
                content=str(e),
                metadata={"error_type": type(e).__name__}
            )
    
    async def __aenter__(self):
        await self.start()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.stop()
